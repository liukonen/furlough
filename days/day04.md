# Day 4 
- CICD in Azure function (git and deploy automatically from repo) and using azure pipes. [Go serverless: Serverless operations with Azure DevOps](https://channel9.msdn.com/Shows/Azure-Friday/Go-serverless-Serverless-operations-with-Azure-DevOps)
	- didn't get a lot out of this... since most of it had everything to do with configuring a pipeline to deploy code through a pipeline and into a hosted server
- grpc [Building-Microservices-with-gRPC-and-NET](https://channel9.msdn.com/Shows/The-Cloud-Native-Show/Building-Microservices-with-gRPC-and-NET) and [intro to grpc](https://channel9.msdn.com/Shows/Visual-Studio-Toolbox/Introduction-to-gRPC?term=grpc&lang-en=true) 
	- This I got more out of, however, they have limited the amount of coding and config between the services... essentially, you have a shared YAML protobuff file, a client, server, and endpoints. Much of the code is now autogenerated off the YAML, and you only need to pull in a service reference, and point it to the YAML file, like WCF WSDLs. 
- also [Introduction-to-GraphQL](https://channel9.msdn.com/Shows/On-NET/Introduction-to-GraphQL) and [Creating-a-GraphQL-Backend](https://channel9.msdn.com/Shows/On-NET/Creating-a-GraphQL-Backend)
	- This was interesting in the idea that with GraphQL, you essentially set up your rest service as a giant 1 call location, and based on your post request object, your output is generated from the response. This is nice in the idea that you are not having to call multiple rest services, however, I can see it becoming something monolithic if not used properly (just give me EVERYTHING)